# 第 1 章：簡介

在本書的開篇，我們會概要性地介紹 C 語言。主要會通過實際的範例讓讀者理解一些 C 語言的基本元素，但對於具體的細節、規則或例外情況會暫且按下不表，而是希望讀者能盡快上手並且撰寫出有用的程序（畢竟大家都沒什麼耐心，對吧？）。

本章將會介紹一些基本概念：
- 變數
- 算術運算
- 流程控制
- 函式
- 基本輸入與輸出

而對於一些編寫較大型應用程式常會涉及到的一些重要特性，如指標、結構或一些巨集等就不在本章的討論範圍內。

## 1.1 入門

一般來說，程式設計師們習慣使用 `Hello World` 程式來作為開篇，當計算機能夠正常在螢幕上輸出 `Hello World` 時，往往代表著開發工具已經準備就緒。

### 1.1.1 撰寫程式碼

在 C 語言中，我們可以用以下程式碼使程式輸出 `Hello World`:

```c
#include <stdio.h>

int main() {
    puts("Hello World");
}
```

讀者可以在任何純文字編輯器中輸入這段程式，並且儲存為 `hello.c` 的純文字檔案。

:::info
在本課程中，讀者可以選擇任何偏愛的純文字編輯器。

如果不曉得如何選擇，可以使用由 Microsoft 公司推出的開放原始碼純文字編輯器 [Visual Studio Code](https://code.visualstudio.com/)，它可以在各種不同的作業系統中被使用，同時也是被廣泛接受的選擇。
:::

### 1.1.2 從程式碼到程式

為了使上一節的程式碼成為可執行的程式，程式設計師通常會依賴名為 _編譯器（Compiler）_ 的特殊程式，它能夠藉由 _編譯（Compile）_ 將程式碼翻譯為計算機能夠理解並執行的機器碼。

在部份 Linux 作業系統中，我們可以使用 `cc` 來編譯程式碼：

```bash
cc hello.c
```

:::info
在不同的作業系統中，往往有著迥異的編譯器與行為，為了降低學習上的門檻與困擾，本書將會使用 GNU C Compiler（通常簡稱為 GCC）作為標準並相容於 LLVM C Frontend（通常簡稱為 Clang）

對於系統的環境安裝與設定，可以參閱 [附錄 A：系統環境安裝與建置](./appendix-01-environment.md)
:::

在編譯完成之後，應該會在相同目錄下見到 `a.out` 的可執行程式，執行 `a.out` 即可在螢幕上顯示 `Hello World`

### 1.1.3 程式碼解說

```c
#include <stdio.h>

int main() {
    puts("Hello World");
}
```

C 語言存在一個特殊的 _函式（Function）_ 稱為 `main` 函式（行3），所有的可執行程式都是由 `main` 函式作為起點。

函式將會被一對花括號 `{}` 包裏，代表的是這個函式實際會被執行哪些 _陳述式（Statement）_ 或運算。

程式設計師有的時候會調用其它函式來幫助他們完成某些工作，被調用的函式可以是自行編寫或是來自於其它先進們所編寫的函式庫。在上述程式碼中，我們使用了 `#include <stdio.h>`，其作用就是告知編譯器我們將會使用標準輸入輸出函式庫。

在 `main` 函式中，我們使用了 `puts` 函式，這就是被定義於 `stdio.h` 的標準輸出函式之一。

為了在函式之間交換資訊，一個常見的做法是使用 _參數（Parameter）_，我們可以觀察到 `main` 函式並不存在任何的參數，而 `puts` 函式中則有一個 `"Hello World"` 參數；用 `""` 包裏的內容通常被稱為 _字串（String）_。

## 1.2 變數與算術表達式

讓我們來看下一個程式：攝氏與華氏轉換器。理想上，它應該可以輸出如下列的溫度對照表：

```
0   32
10  50
20  68
30  86
40  104
50  122
```

我們已知攝氏溫度與華氏溫度的轉換公式為：

$$^\circ\text{F} = ^\circ\text{C} * \frac{9}{5} + 32$$

有了以上的知識，我們可以撰寫以下程式碼，這個程式碼相較於之前的 `Hello World` 稍微長了一些，但並不複雜，並且我們會在這個程式中引入一些新的概念，包括註釋、宣告、常數、變數與算術表達式、循環與格式化輸出。

```c
#include <stdio.h>

#define LOWER 0  // 表達溫度表的下限
#define UPPER 50 // 表達溫度表的上限
#define STEP 10  // 表達溫度表每次會遞增多少度

/* 
 * 當 celsius = 0, 10, ..., 50 時，
 * 分別印出攝氏與華氏溫度對照表
 */
int main() {
    int fahr, celsius;

    celsius = LOWER;
    while (celsius <= UPPER) {
        fahr = celsius * 9 / 5 + 32;
        printf("%d\t%d\n", celsius, fahr);
        celsius = celsius + STEP;
    }
}
```

### 1.2.1 註釋

我們率先看到第 3, 4, 5 行，位於 `//` 之後的內容表示 _註釋（Comment）_，註釋可以是任何內容，編譯器會自動忽略 `//` 之後的文字直到換行為止。

在第 7 ~ 10 行中，使用了 `/**/` 包裏了一段文字，這是另一種註釋形式，它能夠包含多行內容。

:::info
儘管在標準上註釋並不限制使用什麼文字或語言撰寫，但習慣上大部份程式設計師仍會使用英文作為溝通的標準。
:::

### 1.2.2 常數

在 C 語言中，可以使用 `#define` 來定義 _常數（Constant）_，在上述程式中我們定義了三個常數：

```c
#define LOWER 0
#define UPPER 50
#define STEP 10
```

編譯器在 _前置處理（Preprocessing）_ 的過程中，會將常數填入回程式碼中，也就是說上述程式碼完全等價於以下程式碼，程式設計師往往會為了可讀性與可複用性來使用 `#define` 來定義常數。

```c
#include <stdio.h>

int main() {
    int fahr, celsius;

    celsius = 0;
    while (celsius <= 50) {
        fahr = celsius * 9 / 5 + 32;
        printf("%d\t%d\n", celsius, fahr);
        celsius = celsius + 10;
    }
}
```

### 1.2.3 變數

在第 12 行中，使用 `int fahr, celsius;` 宣告 _整數（Integer）_ 變數，而變數通常用於暫存即將會被使用到的資料。

在 C 語言中，變數必須先宣告才能使用，而宣告通常被放置在函式的起始處，位於任何可執行程式之前。

在變數宣告時，程式設計師必須先指定其資料型態，例如在此處使用 `int` 代表宣告的是整數變數。

C 語言內建了一些資料型態用於表示不同的資料類型，例如上面用到的 `int` 代表整數，或是與其相對應的 `float` 代表浮點數（通常是指帶小數點的數或指數），我們會在後續的章節中詳細討論這些資料型態。

### 1.2.4 迴圈

計算機相較於人類有著一大優勢在於它能夠重複地執行有規則的計算，而迴圈就是它的具體實踐。

在第 15 行中，我們使用了 `while` 迴圈：

```c
while (celsius <= UPPER) {
    // ...
}
```

`while` 迴圈是按照以下規則運作的：測試 `()` 內的條件，如果成立則執行循環體（`{}` 包裏的內容被稱為循環體），並且會重複執行直到條件不成立為止。

當條件不成立，則會跳過整個循環體然後執行下一個陳述式，因為目前的程式碼在 `while` 迴圈之後沒有其它陳述式，程式到此結束。

:::info
若循環體只有一個陳述式，則 `{}` 是可以省略的，例如：

```c
while (i < 10)
    i = i * 2;
```

可以觀察到，在循環體中會加入一些空白，這樣就可以很容易地看出程式碼的邏輯結構。

編譯器並不關心程式碼的外觀，但是正確的格式有助於增加程式的可讀性以及增加其它人協作的便利性。
:::

### 1.2.5 算術表達式與賦值

在上述的程式碼中，最核心的部份當屬第 16 行循環體中的陳述式：

```c
fahr = celsius * 9 / 5 + 32;
```

用於計算指定的攝氏溫度對應的華氏溫度，並且將結果 _賦值（Assignment）_ 給變數 `fahr`。

可以注意到，這裡用了 `celsius * 9 / 5`，而不是 `9 / 5 * celsius`，這是因為 C 語言的算術遵循數學的基本規則「先乘除後加減」，但是整數運算的除法會把小數部份捨棄，因此 `9 / 5 * celsius` 會等於 `1 * celsius`。

### 1.2.6 格式化輸出

不同於上一節使用 `puts` 輸出，這裡使用了 `printf` 函式。

`printf` 是一個通用格式化輸出函式，該函式允許一個以上的參數，其中第一個參數是輸出的字串格式，其中的每個 `%` 表示其後續的參數進行替換的位置。

```c
printf("%d\t%d\n", celsius, fahr);
```

其中 `%d` 指定一個整數參數，因為在格式中存在 2 個 `%d`，因此後面需要指定兩個整數 `celsius` 與 `fahr` 作為 `printf` 的參數。在使用 `printf` 時必需特別注意，參數的資料型態與數量都必需配對，否則將會出現錯誤的結果。

與 `puts` 不同的是，由 `printf` 輸出的內容並不會自動換行，因此必需在後面加上 `\n` 指示輸出字串需要換行，我們將這些有特殊作用的字元稱為 _逃脫字元（Escape Character）_。不難注意到，上述的程式在兩個 `%d` 中間也加入了一個 `\t`，這是一個製表逃脫字元，表示這之間要留一個製表符的空間。

:::info
`puts` 與 `printf` 函式並不是 C 語言本身的一部份，C 語言本身並沒有定義輸入與輸出功能。它們僅僅只是標準函式庫 `stdio.h` 中一個有用的函式，這些標準函式在 C 語言程式碼中通常都可以使用，因為 ANSI 標準規範了 `printf` 與 `puts` 函式的行為，對於任何符合該標準的編譯器與函式庫而言，這些函式都應該存在相同的行為。
:::

現在的程式存在一個小毛病：輸出的數字不是向右對齊的，這導致輸出結果不太美觀。

所幸只要在 `printf` 函式中的第一個參數 `%d` 中指出寬度，輸出的結果將會向右對齊，例如我們把它改成：

```c
printf("%2d\t%3d\n", celsius, fahr);
```

這樣 `celsius` 佔 2 字寬、`fahr` 佔 3 字寬，輸出的結果如下所示：

```
 0	 32
10	 50
20	 68
30	 86
40	104
50	122
```

## 1.3 for 陳述式

對於某些特定的任務，往往都有多種不同的解決方案。下述的程式碼也可以實現在 1.2 節中提到的攝氏華氏轉換程式：

```c
#include <stdio.h>

#define LOWER 0
#define UPPER 50
#define STEP 10

int main() {
    for (int celsius = LOWER; celsius <= UPPER; celsius += STEP) {
        int fahr = celsius * 9 / 5 + 32;
        printf("%2d\t%3d\n", celsius, fahr);
    }
}
```

`for` 陳述式是另一種循環實踐方式，可以想成是對 `while` 的擴充。相較於 `while`，會發現 `for` 的操作上更加直觀一些。

在 `for` 的 `()` 中可以用 `;` 分為三個部份：
- `int celsius = LOWER` 初始化：只有在進入循環之前執行一次 
- `celsius <= UPPER` 條件測試：在每一次循環開始之前都會確認，如果符合條件則執行循環體 
- `celsuius += STEP` 步進處理：在每次循環體結束之後就會執行一次

:::info
你可能有注意到，在 1.2.3 中我們曾經提到過：
> 在 C 語言中，變數必須先宣告才能使用，而宣告通常被放置在函式的起始處，位於任何可執行程式之前。

而在本章中的寫法並不符合這樣的規則，因為在 `for` 的初始化時才宣告了 `celsius` 變數，甚至是在循環體中才宣告了 `fahr` 變數。

這麼做的理由是因為有時候程式設計師會希望特定的變數只在某些區域可以使用，從而避免影響到其它的區塊。
:::

在實際的程式設計過程中，可以自由選擇 while 或 for 中任意一種，主要取決於哪種方式更加清晰。

## 1.4 字元輸入與輸出

接下來，我們來看一組與 _字元（Character）_ 資料有關的程式。讀者將會發現，許多程式只不是這裡討論的程式的擴充版本而已。

標準函式庫中提供的輸入與輸出功能非常簡單，無論從哪裡輸入、輸出到哪裡，其輸入及輸出都是按照字元串流的方式處理。字元串流是由多行字元構成的序列，每行字可以由多個字元組成，並且行末會是換行字元 `\n`。

標準函式庫提供了一次性讀、寫一個字元的函式，其中最簡單的就是 `getchar` 與 `putchar` 這兩個函式。每次調用時，`getchar` 函式會從字元串流中讀入下一個輸入，並且將其作為結果返回。

舉例來說，可以利用以下陳述式，從標準輸入裝置（通常是指鍵盤）讀入一個字元 `c`：

```c
int c = getchar();
```

而每次調用 `putchar` 函式時，將會在標準輸出裝置（通常是指螢幕）輸出一個字元：

```c
putchar(c);
```

### 1.4.1 輸入複製

藉由 `getchar` 與 `putchar`，就可以在不了解其它輸入與輸出知識的情況下編寫相當實用的程式碼。讓我們來看看一個最簡單的範例：將輸入的字元一個接一個輸出。

```c
#include <stdio.h>

int main() {
    int c;

    c = getchar();
    while(c != EOF) {
        putchar(c);
        c = getchar();
    }
}
```

首先，我們先看看 `c != EOF` 這個判斷式：我們需要確定用戶的輸入何時結束，當用戶輸入結束時 `getchar` 將返回一個特殊值，這個特殊值與任何實際的字元都不相同，我們稱其為 `EOF`（end of file，文件結束）。

對於一些經驗比較豐富的 C 語言程式設計師，可以把程式碼寫得更精煉一些。在 C 語言中 `c = getchar()` 這樣的賦值操作是一個陳述式，並且具有一個值（既賦值後 `=` 左邊變數保存的值）。

因此，上述的輸入複製程式可以改寫為：

```c
#include <stdio.h>

int main() {
    int c;

    while ((c = getchar()) != EOF) {
        putchar(c);
    }
}
```

對於修改後的程式，`while` 會讀一個字元並賦值給 `c`，然後測試該字元是否為 `EOF`：如果不是，則執行循環體並顯示該字元，隨後再重複執行 `while`；當到達 `EOF` 時，則結束 `main` 函式執行。

以上程式透過將輸入集中化，使 `getchar` 函式只出現了一次，從而縮短程式碼。習慣這種風格後，讀者會發現按照這種方式撰寫程式碼擁有更高的可讀性。

我們將會經常看到這種風格，然而如果過多地使用這種類型的複雜表達方式，可能會使程式碼變得難以理解，這部份就需要憑藉程式設計師的經驗來進行取捨。

需要注意的是，因為賦值使用的 `=` 的優先權較低，所以我們必須對 `(c = getchar())` 加上括號來提高執行時的優先權。

### 1.4.2 字元計算

利用以下的程式對字元進行計數，實際上它與 1.4.1 的複製程式類似

```c
#include <stdio.h>

int main() {
    int nc = 0;

    while (getchar() != EOF)
        ++nc;
    printf("%d\n", nc);
}
```

我們在第 7 行的 `++nc` 中引入了一個新的 _運算元（Operator）_ `++`，其功能是執行遞增操作，會使 `nc` 的值加 1；當然，我們也可以寫成 `nc = nc + 1`，但 `++nc` 顯得更加精煉一些且通常效率較高。

與 `++` 相對應的還有 `--` 運算符，用於遞減操作。這兩個運算符都可以作為前綴形式（如 `++nc`）與後綴形式（如 `nc++`），在此處我們僅值用前綴形式。

對於現代硬體設備來說，使用 `int` 是相當足夠的，但對於比較大的內容可能會使用 `double`（倍精度浮點數）來處理更大的數字。我們在這裡不使用 `while` 循環，而用 `for` 循環來展示撰寫程式的另一種方式：

```c
#include <stdio.h>

int main() {
    double nc;

    for (nc = 0; getchar() != EOF; ++nc)
        ;
    printf("%.0f\n", nc);
}
```

對於 `double` 類型，應該使用 `%f` 才能夠在 `printf` 中正確表達，而此處我們使用 `%.0f` 是為了強制不印出小數點及小數部份。

在這段程式中，`for` 的循環體為空，這是因為所有的工作都在條件判斷部份與步進處理的部份完成，但是循環體是必須存在的，因此這裡使用單獨的 `;` 替代。單獨的 `;` 稱為 _空陳述式（Null Statement）_，而將它單獨放一行也是為了更加醒目。

### 1.4.3 行數計算

接下來的這個程式用於統計輸入中的行數。我們在上面提過，標準庫會保證輸入的字元串流會以行的方式呈現，每一行以換行字元 `\n` 結尾。因此，統計行數等價於統計換行字元 `\n` 的數量。

```c
#include <stdio.h>

int main() {
    int c, nl = 0;

    while ((c = getchar()) != EOF) {
        if (c == '\n')
            ++nl;
    }
    printf("%d\n", nl);
}
```

在上述的程式中，`while` 的循環體是一個 `if` 陳述式來控制自增 `++nl`。`if` 陳述式會先測試 `()` 中的條件是否為真，如果條件為真則執行其後的陳述式（與 `while` 類似，可以用 `{}` 包裏多組陳述式），此處再次用空格的方式表明陳述式之間的相對關係。

雙等號 `==` 是 C 語言中表示「等於」關係的運算元，因為 C 語言已經使用 `=` 代表賦值關係，因此這裡用 `==` 以示區分。需要特別注意的是，在表示「等於」關係的時候務必使用 `==`，初學者有時會錯誤地寫成 `=`，即便誤用結果仍是合乎規則的，因此編譯器並不會給出警告訊息。

在單引號 `''` 中的字元表示一個值，該值等於這個字元在計算機字元定義對應的數值，我們稱之為 _字元常數（Character Contant）_，但其實它是一個整數型態的另一種寫法而已。例如 `'A'` 是一個字元常數，它在 ASCII 字元集中的值為 `65`（即在計算機中，字元 A 是由 65 表達）。當然，習慣上往往用 `'A'` 要比用 `65` 來得好，因為意義更清楚、有更佳的可讀性。

字元常數中使用的逃脫字元也是合法的字元常數，例如 `'\n'` 代表換行，在 ASCII 中的值為 `10`。我們應該可以注意到，`'\n'` 是單個字元，在運算式中只是一個整數而已。

### 1.4.4 單字計算

我們將介紹第 4 個實用程式，用於統計行數、單字數與字元數。這裡對單字的定義比較寬鬆：不包含空格、制表字元 `\t` 或換行字元 `\n` 的字元序列。

```c
#include <stdio.h>

#define IN 1  // inside a word
#define OUT 0 // outside a word

int main() {
    int c, nl, nw, nc, state;

    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        if (c == ' ' || c == '\n' || c == '\t')
            state = OUT;
        else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
    printf("%d %d %d\n", nl, nw, nc);
}
```

當程式執行時，每當遇到單字的第一個字元時，它就會作為一個新單字加以計算。`state` 變數記錄程式當前是否正位於一個單字之中，它的初始值是「不在單字中」，即初始賦值為 `OUT`。我們在這裡使用了常數 `IN` 跟 `OUT`，而沒有使用其對應的數值 `1` 與 `0`，這樣能使程式碼更具備可讀性。在規模較小的程式中，這種做法可能看不出有什麼優勢，但在較大型的程式中，如果從一開始就這麼做，藉由增加一點工作量提高程式的可讀性帶來的好處往往都是划算的。讀者會發現，如果程式中的 _魔術數（Magic Number）_ 都用這種常數的形式出現，在大量修改程式時會相對容易得多。

在第 10 行中 `nl = nw = nc = 0` 會把其中的三個變數 `nl`、`nw` 與 `nc` 都設為 `0`，這種用法很常見，但是要注意一項規則：在兼有值與賦值的表達式中，賦值結合的次序是由右往左。因此上面的陳述式等價於 `nl = (nw = (nc = 0))`，運算元的優先順序往往會成為難以除錯的根源，如果實在不確定可以分別對其賦值會是比較好的做法。

在第 15 行中，使用了 `||` 運算元代表「或」，因此 `if (c == ' ' || c == '\n' || c == '\t')` 可以被口語地解釋為「如果 `c` 是空格，或 `c` 是換行字元，或 `c` 是製表字元」（前面有提到，`\t` 是製表字元的可見表式形態）。

相應地， `&&` 運算元代表的是「和」，由 `&&` 或 `||` 連接的運算式會由左往右求值，並且保證求值的過程中只要能夠判斷最終結果為真或假，求值就會立即中止。如果 `c` 已經確定是空格，就沒有必要再測試它後面是換行字元或製表字元，這樣會直接跳過後面兩個測試。

在上述程式中還包含一個 `else` 部份，它會指定當 `if` 條件判斷不成立時所要執行的動作，其一般形式為：

```c
if (運算式)
    陳述式 1
else
    陳述式 2
```

其中，`if-else` 中僅會有一個陳述式被執行。如果運算式的值為真，則執行 `陳述式 1`，反之類執行 `陳述式 2`。當然，上述的 `陳述式 1` 與 `陳述式 2` 也可以利用 `{}` 來包裏多個陳述式。