# 第 1 章：簡介

在本書的開篇，我們會概要性地介紹 C 語言。主要會通過實際的範例讓讀者理解一些 C 語言的基本元素，但對於具體的細節、規則或例外情況會暫且按下不表，而是希望讀者能盡快上手並且撰寫出有用的程序（畢竟大家都沒什麼耐心，對吧？）。

本章將會介紹一些基本概念：
- 變數
- 算術運算
- 流程控制
- 函式
- 基本輸入與輸出

而對於一些編寫較大型應用程式常會涉及到的一些重要特性，如指標、結構或一些巨集等就不在本章的討論範圍內。

## 1.1 入門

一般來說，程式設計師們習慣使用 `Hello World` 程式來作為開篇，當計算機能夠正常在螢幕上輸出 `Hello World` 時，往往代表著開發工具已經準備就緒。

### 1.1.1 撰寫程式碼

在 C 語言中，我們可以用以下程式碼使程式輸出 `Hello World`:

```c
#include <stdio.h>

int main() {
    puts("Hello World");
}
```

讀者可以在任何純文字編輯器中輸入這段程式，並且儲存為 `hello.c` 的純文字檔案。

:::info
在本課程中，讀者可以選擇任何偏愛的純文字編輯器。

如果不曉得如何選擇，可以使用由 Microsoft 公司推出的開放原始碼純文字編輯器 [Visual Studio Code](https://code.visualstudio.com/)，它可以在各種不同的作業系統中被使用，同時也是被廣泛接受的選擇。
:::

### 1.1.2 從程式碼到程式

為了使上一節的程式碼成為可執行的程式，程式設計師通常會依賴名為 _編譯器（Compiler）_ 的特殊程式，它能夠藉由 _編譯（Compile）_ 將程式碼翻譯為計算機能夠理解並執行的機器碼。

在部份 Linux 作業系統中，我們可以使用 `cc` 來編譯程式碼：

```bash
cc hello.c
```

:::info
在不同的作業系統中，往往有著迥異的編譯器與行為，為了降低學習上的門檻與困擾，本書將會使用 GNU C Compiler（通常簡稱為 GCC）作為標準並相容於 LLVM C Frontend（通常簡稱為 Clang）

對於系統的環境安裝與設定，可以參閱 [附錄 A：系統環境安裝與建置](./appendix-01-environment.md)
:::

在編譯完成之後，應該會在相同目錄下見到 `a.out` 的可執行程式，執行 `a.out` 即可在螢幕上顯示 `Hello World`

### 1.1.3 程式碼解說

```c
#include <stdio.h>

int main() {
    puts("Hello World");
}
```

C 語言存在一個特殊的 _函式（Function）_ 稱為 `main` 函式（行3），所有的可執行程式都是由 `main` 函式作為起點。

函式將會被一對花括號 `{}` 包裏，代表的是這個函式實際會被執行哪些 _陳述式（Statement）_ 或運算。

程式設計師有的時候會調用其它函式來幫助他們完成某些工作，被調用的函式可以是自行編寫或是來自於其它先進們所編寫的函式庫。在上述程式碼中，我們使用了 `#include <stdio.h>`，其作用就是告知編譯器我們將會使用標準輸入輸出函式庫。

在 `main` 函式中，我們使用了 `puts` 函式，這就是被定義於 `stdio.h` 的標準輸出函式之一。

為了在函式之間交換資訊，一個常見的做法是使用 _參數（Parameter）_，我們可以觀察到 `main` 函式並不存在任何的參數，而 `puts` 函式中則有一個 `"Hello World"` 參數；用 `""` 包裏的內容通常被稱為 _字串（String）_。

## 1.2 變數與算術表達式

讓我們來看下一個程式：攝氏與華氏轉換器。理想上，它應該可以輸出如下列的溫度對照表：

```
0   32
10  50
20  68
30  86
40  104
50  122
```

我們已知攝氏溫度與華氏溫度的轉換公式為：

$$^\circ\text{F} = ^\circ\text{C} * \frac{9}{5} + 32$$

有了以上的知識，我們可以撰寫以下程式碼，這個程式碼相較於之前的 `Hello World` 稍微長了一些，但並不複雜，並且我們會在這個程式中引入一些新的概念，包括註釋、宣告、常數、變數與算術表達式、循環與格式化輸出。

```c
#include <stdio.h>

#define LOWER 0  // 表達溫度表的下限
#define UPPER 50 // 表達溫度表的上限
#define STEP 10  // 表達溫度表每次會遞增多少度

/* 
 * 當 celsius = 0, 10, ..., 50 時，
 * 分別印出攝氏與華氏溫度對照表
 */
int main() {
    int fahr, celsius;

    celsius = LOWER;
    while (celsius <= UPPER) {
        fahr = celsius * 9 / 5 + 32;
        printf("%d\t%d\n", celsius, fahr);
        celsius = celsius + STEP;
    }
}
```

### 1.2.1 註釋

我們率先看到第 3, 4, 5 行，位於 `//` 之後的內容表示 _註釋（Comment）_，註釋可以是任何內容，編譯器會自動忽略 `//` 之後的文字直到換行為止。

在第 7 ~ 10 行中，使用了 `/**/` 包裏了一段文字，這是另一種註釋形式，它能夠包含多行內容。

:::info
儘管在標準上註釋並不限制使用什麼文字或語言撰寫，但習慣上大部份程式設計師仍會使用英文作為溝通的標準。
:::

### 1.2.2 常數

在 C 語言中，可以使用 `#define` 來定義 _常數（Constant）_，在上述程式中我們定義了三個常數：

```c
#define LOWER 0
#define UPPER 50
#define STEP 10
```

編譯器在 _前置處理（Preprocessing）_ 的過程中，會將常數填入回程式碼中，也就是說上述程式碼完全等價於以下程式碼，程式設計師往往會為了可讀性與可複用性來使用 `#define` 來定義常數。

```c
#include <stdio.h>

int main() {
    int fahr, celsius;

    celsius = 0;
    while (celsius <= 50) {
        fahr = celsius * 9 / 5 + 32;
        printf("%d\t%d\n", celsius, fahr);
        celsius = celsius + 10;
    }
}
```

### 1.2.3 變數

在第 12 行中，使用 `int fahr, celsius;` 宣告 _整數（Integer）_ 變數，而變數通常用於暫存即將會被使用到的資料。

在 C 語言中，變數必須先宣告才能使用，而宣告通常被放置在函式的起始處，位於任何可執行程式之前。

在變數宣告時，程式設計師必須先指定其資料型態，例如在此處使用 `int` 代表宣告的是整數變數。

C 語言內建了一些資料型態用於表示不同的資料類型，例如上面用到的 `int` 代表整數，或是與其相對應的 `float` 代表浮點數（通常是指帶小數點的數或指數），我們會在後續的章節中詳細討論這些資料型態。

### 1.2.4 迴圈

計算機相較於人類有著一大優勢在於它能夠重複地執行有規則的計算，而迴圈就是它的具體實踐。

在第 15 行中，我們使用了 `while` 迴圈：

```c
while (celsius <= UPPER) {
    // ...
}
```

`while` 迴圈是按照以下規則運作的：測試 `()` 內的條件，如果成立則執行循環體（`{}` 包裏的內容被稱為循環體），並且會重複執行直到條件不成立為止。

當條件不成立，則會跳過整個循環體然後執行下一個陳述式，因為目前的程式碼在 `while` 迴圈之後沒有其它陳述式，程式到此結束。

:::info
若循環體只有一個陳述式，則 `{}` 是可以省略的，例如：

```c
while (i < 10)
    i = i * 2;
```

可以觀察到，在循環體中會加入一些空白，這樣就可以很容易地看出程式碼的邏輯結構。

編譯器並不關心程式碼的外觀，但是正確的格式有助於增加程式的可讀性以及增加其它人協作的便利性。
:::

### 1.2.5 算術表達式與賦值

在上述的程式碼中，最核心的部份當屬第 16 行循環體中的陳述式：

```c
fahr = celsius * 9 / 5 + 32;
```

用於計算指定的攝氏溫度對應的華氏溫度，並且將結果 _賦值（Assignment）_ 給變數 `fahr`。

可以注意到，這裡用了 `celsius * 9 / 5`，而不是 `9 / 5 * celsius`，這是因為 C 語言的算術遵循數學的基本規則「先乘除後加減」，但是整數運算的除法會把小數部份捨棄，因此 `9 / 5 * celsius` 會等於 `1 * celsius`。

### 1.2.6 格式化輸出

不同於上一節使用 `puts` 輸出，這裡使用了 `printf` 函式。

`printf` 是一個通用格式化輸出函式，該函式允許一個以上的參數，其中第一個參數是輸出的字串格式，其中的每個 `%` 表示其後續的參數進行替換的位置。

```c
printf("%d\t%d\n", celsius, fahr);
```

其中 `%d` 指定一個整數參數，因為在格式中存在 2 個 `%d`，因此後面需要指定兩個整數 `celsius` 與 `fahr` 作為 `printf` 的參數。在使用 `printf` 時必需特別注意，參數的資料型態與數量都必需配對，否則將會出現錯誤的結果。

與 `puts` 不同的是，由 `printf` 輸出的內容並不會自動換行，因此必需在後面加上 `\n` 指示輸出字串需要換行，我們將這些有特殊作用的字元稱為 _逃脫字元（Escape Character）_。不難注意到，上述的程式在兩個 `%d` 中間也加入了一個 `\t`，這是一個製表逃脫字元，表示這之間要留一個製表符的空間。

:::info
`puts` 與 `printf` 函式並不是 C 語言本身的一部份，C 語言本身並沒有定義輸入與輸出功能。它們僅僅只是標準函式庫 `stdio.h` 中一個有用的函式，這些標準函式在 C 語言程式碼中通常都可以使用，因為 ANSI 標準規範了 `printf` 與 `puts` 函式的行為，對於任何符合該標準的編譯器與函式庫而言，這些函式都應該存在相同的行為。
:::

現在的程式存在一個小毛病：輸出的數字不是向右對齊的，這導致輸出結果不太美觀。

所幸只要在 `printf` 函式中的第一個參數 `%d` 中指出寬度，輸出的結果將會向右對齊，例如我們把它改成：

```c
printf("%2d\t%3d\n", celsius, fahr);
```

這樣 `celsius` 佔 2 字寬、`fahr` 佔 3 字寬，輸出的結果如下所示：

```
 0	 32
10	 50
20	 68
30	 86
40	104
50	122
```

## 1.3 for 陳述式

對於某些特定的任務，往往都有多種不同的解決方案。下述的程式碼也可以實現在 1.2 節中提到的攝氏華氏轉換程式：

```c
#include <stdio.h>

#define LOWER 0
#define UPPER 50
#define STEP 10

int main() {
    for (int celsius = LOWER; celsius <= UPPER; celsius += STEP) {
        int fahr = celsius * 9 / 5 + 32;
        printf("%2d\t%3d\n", celsius, fahr);
    }
}
```

`for` 陳述式是另一種循環實踐方式，可以想成是對 `while` 的擴充。相較於 `while`，會發現 `for` 的操作上更加直觀一些。

在 `for` 的 `()` 中可以用 `;` 分為三個部份：
- `int celsius = LOWER` 初始化：只有在進入循環之前執行一次 
- `celsius <= UPPER` 條件測試：在每一次循環開始之前都會確認，如果符合條件則執行循環體 
- `celsuius += STEP` 步進處理：在每次循環體結束之後就會執行一次

:::info
你可能有注意到，在 1.2.3 中我們曾經提到過：
> 在 C 語言中，變數必須先宣告才能使用，而宣告通常被放置在函式的起始處，位於任何可執行程式之前。

而在本章中的寫法並不符合這樣的規則，因為在 `for` 的初始化時才宣告了 `celsius` 變數，甚至是在循環體中才宣告了 `fahr` 變數。

這麼做的理由是因為有時候程式設計師會希望特定的變數只在某些區域可以使用，從而避免影響到其它的區塊。
:::

在實際的程式設計過程中，可以自由選擇 while 或 for 中任意一種，主要取決於哪種方式更加清晰。

## 1.4 字元輸入與輸出

接下來，我們來看一組與 _字元（Character）_ 資料有關的程式。讀者將會發現，許多程式只不是這裡討論的程式的擴充版本而已。

標準函式庫中提供的輸入與輸出功能非常簡單，無論從哪裡輸入、輸出到哪裡，其輸入及輸出都是按照字元串流的方式處理。字元串流是由多行字元構成的序列，每行字可以由多個字元組成，並且行末會是換行字元 `\n`。

標準函式庫提供了一次性讀、寫一個字元的函式，其中最簡單的就是 `getchar` 與 `putchar` 這兩個函式。每次調用時，`getchar` 函式會從字元串流中讀入下一個輸入，並且將其作為結果回傳。

舉例來說，可以利用以下陳述式，從標準輸入裝置（通常是指鍵盤）讀入一個字元 `c`：

```c
int c = getchar();
```

而每次調用 `putchar` 函式時，將會在標準輸出裝置（通常是指螢幕）輸出一個字元：

```c
putchar(c);
```

### 1.4.1 輸入複製

藉由 `getchar` 與 `putchar`，就可以在不了解其它輸入與輸出知識的情況下編寫相當實用的程式碼。讓我們來看看一個最簡單的範例：將輸入的字元一個接一個輸出。

```c
#include <stdio.h>

int main() {
    int c;

    c = getchar();
    while(c != EOF) {
        putchar(c);
        c = getchar();
    }
}
```

首先，我們先看看 `c != EOF` 這個判斷式：我們需要確定用戶的輸入何時結束，當用戶輸入結束時 `getchar` 將回傳一個特殊值，這個特殊值與任何實際的字元都不相同，我們稱其為 `EOF`（end of file，文件結束）。

對於一些經驗比較豐富的 C 語言程式設計師，可以把程式碼寫得更精煉一些。在 C 語言中 `c = getchar()` 這樣的賦值操作是一個陳述式，並且具有一個值（既賦值後 `=` 左邊變數保存的值）。

因此，上述的輸入複製程式可以改寫為：

```c
#include <stdio.h>

int main() {
    int c;

    while ((c = getchar()) != EOF) {
        putchar(c);
    }
}
```

對於修改後的程式，`while` 會讀一個字元並賦值給 `c`，然後測試該字元是否為 `EOF`：如果不是，則執行循環體並顯示該字元，隨後再重複執行 `while`；當到達 `EOF` 時，則結束 `main` 函式執行。

以上程式透過將輸入集中化，使 `getchar` 函式只出現了一次，從而縮短程式碼。習慣這種風格後，讀者會發現按照這種方式撰寫程式碼擁有更高的可讀性。

我們將會經常看到這種風格，然而如果過多地使用這種類型的複雜表達方式，可能會使程式碼變得難以理解，這部份就需要憑藉程式設計師的經驗來進行取捨。

需要注意的是，因為賦值使用的 `=` 的優先權較低，所以我們必須對 `(c = getchar())` 加上括號來提高執行時的優先權。

### 1.4.2 字元計算

利用以下的程式對字元進行計數，實際上它與 1.4.1 的複製程式類似

```c
#include <stdio.h>

int main() {
    int nc = 0;

    while (getchar() != EOF)
        ++nc;
    printf("%d\n", nc);
}
```

我們在第 7 行的 `++nc` 中引入了一個新的 _運算元（Operator）_ `++`，其功能是執行遞增操作，會使 `nc` 的值加 1；當然，我們也可以寫成 `nc = nc + 1`，但 `++nc` 顯得更加精煉一些且通常效率較高。

與 `++` 相對應的還有 `--` 運算符，用於遞減操作。這兩個運算符都可以作為前綴形式（如 `++nc`）與後綴形式（如 `nc++`），在此處我們僅值用前綴形式。

對於現代硬體設備來說，使用 `int` 是相當足夠的，但對於比較大的內容可能會使用 `double`（倍精度浮點數）來處理更大的數字。我們在這裡不使用 `while` 循環，而用 `for` 循環來展示撰寫程式的另一種方式：

```c
#include <stdio.h>

int main() {
    double nc;

    for (nc = 0; getchar() != EOF; ++nc)
        ;
    printf("%.0f\n", nc);
}
```

對於 `double` 類型，應該使用 `%f` 才能夠在 `printf` 中正確表達，而此處我們使用 `%.0f` 是為了強制不印出小數點及小數部份。

在這段程式中，`for` 的循環體為空，這是因為所有的工作都在條件判斷部份與步進處理的部份完成，但是循環體是必須存在的，因此這裡使用單獨的 `;` 替代。單獨的 `;` 稱為 _空陳述式（Null Statement）_，而將它單獨放一行也是為了更加醒目。

### 1.4.3 行數計算

接下來的這個程式用於統計輸入中的行數。我們在上面提過，標準庫會保證輸入的字元串流會以行的方式呈現，每一行以換行字元 `\n` 結尾。因此，統計行數等價於統計換行字元 `\n` 的數量。

```c
#include <stdio.h>

int main() {
    int c, nl = 0;

    while ((c = getchar()) != EOF) {
        if (c == '\n')
            ++nl;
    }
    printf("%d\n", nl);
}
```

在上述的程式中，`while` 的循環體是一個 `if` 陳述式來控制自增 `++nl`。`if` 陳述式會先測試 `()` 中的條件是否為真，如果條件為真則執行其後的陳述式（與 `while` 類似，可以用 `{}` 包裏多組陳述式），此處再次用空格的方式表明陳述式之間的相對關係。

雙等號 `==` 是 C 語言中表示「等於」關係的運算元，因為 C 語言已經使用 `=` 代表賦值關係，因此這裡用 `==` 以示區分。需要特別注意的是，在表示「等於」關係的時候務必使用 `==`，初學者有時會錯誤地寫成 `=`，即便誤用結果仍是合乎規則的，因此編譯器並不會給出警告訊息。

在單引號 `''` 中的字元表示一個值，該值等於這個字元在計算機字元定義對應的數值，我們稱之為 _字元常數（Character Contant）_，但其實它是一個整數型態的另一種寫法而已。例如 `'A'` 是一個字元常數，它在 ASCII 字元集中的值為 `65`（即在計算機中，字元 A 是由 65 表達）。當然，習慣上往往用 `'A'` 要比用 `65` 來得好，因為意義更清楚、有更佳的可讀性。

字元常數中使用的逃脫字元也是合法的字元常數，例如 `'\n'` 代表換行，在 ASCII 中的值為 `10`。我們應該可以注意到，`'\n'` 是單個字元，在運算式中只是一個整數而已。

### 1.4.4 單字計算

我們將介紹第 4 個實用程式，用於統計行數、單字數與字元數。這裡對單字的定義比較寬鬆：不包含空格、制表字元 `\t` 或換行字元 `\n` 的字元序列。

```c
#include <stdio.h>

#define IN 1  // inside a word
#define OUT 0 // outside a word

int main() {
    int c, nl, nw, nc, state;

    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        if (c == ' ' || c == '\n' || c == '\t')
            state = OUT;
        else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
    printf("%d %d %d\n", nl, nw, nc);
}
```

當程式執行時，每當遇到單字的第一個字元時，它就會作為一個新單字加以計算。`state` 變數記錄程式當前是否正位於一個單字之中，它的初始值是「不在單字中」，即初始賦值為 `OUT`。我們在這裡使用了常數 `IN` 跟 `OUT`，而沒有使用其對應的數值 `1` 與 `0`，這樣能使程式碼更具備可讀性。在規模較小的程式中，這種做法可能看不出有什麼優勢，但在較大型的程式中，如果從一開始就這麼做，藉由增加一點工作量提高程式的可讀性帶來的好處往往都是划算的。讀者會發現，如果程式中的 _魔術數（Magic Number）_ 都用這種常數的形式出現，在大量修改程式時會相對容易得多。

在第 10 行中 `nl = nw = nc = 0` 會把其中的三個變數 `nl`、`nw` 與 `nc` 都設為 `0`，這種用法很常見，但是要注意一項規則：在兼有值與賦值的表達式中，賦值結合的次序是由右往左。因此上面的陳述式等價於 `nl = (nw = (nc = 0))`，運算元的優先順序往往會成為難以除錯的根源，如果實在不確定可以分別對其賦值會是比較好的做法。

在第 15 行中，使用了 `||` 運算元代表「或」，因此 `if (c == ' ' || c == '\n' || c == '\t')` 可以被口語地解釋為「如果 `c` 是空格，或 `c` 是換行字元，或 `c` 是製表字元」（前面有提到，`\t` 是製表字元的可見表式形態）。

相應地， `&&` 運算元代表的是「和」，由 `&&` 或 `||` 連接的運算式會由左往右求值，並且保證求值的過程中只要能夠判斷最終結果為真或假，求值就會立即中止。如果 `c` 已經確定是空格，就沒有必要再測試它後面是換行字元或製表字元，這樣會直接跳過後面兩個測試。

在上述程式中還包含一個 `else` 部份，它會指定當 `if` 條件判斷不成立時所要執行的動作，其一般形式為：

```c
if (運算式)
    陳述式 1
else
    陳述式 2
```

其中，`if-else` 中僅會有一個陳述式被執行。如果運算式的值為真，則執行 `陳述式 1`，反之類執行 `陳述式 2`。當然，上述的 `陳述式 1` 與 `陳述式 2` 也可以利用 `{}` 來包裏多個陳述式。

## 1.5 陣列

在這部份內容中，我們會撰寫一個程式，用於統計各數字、空白字元（包括空格、製表字元與換行字元）以及所有其它字元出現的次數。這個程式的實用意義不大，但我們可以透過這個程式來討論 C 語言的方方面面。

所有的輸入字元可以分為 12 個類型，因此用一個 _陣列（Array）_ 存放各數字出現的次數，這遠比用 10 個獨立的變數存放更方便，以下是第一個實作的版本：

```c
#include <stdio.h>

int main() {
    int nwhite = 0, nother = 0;
    int ndigit[10] = {0};

    for (char c = getchar(); c != EOF; c = getchar()) {
        if (c >= '0' && c <= '9')
            ++ndigit[c-'0'];
        else if (c == ' ' || c == '\n' || c == '\t')
            ++nwhite;
        else
            ++nother;
    }

    printf("digits =");
    for (int i = 0; i < 10; i++) {
        printf(" %d", ndigit[i]);
    }
    printf(", white space = %d, other = %d\n", nwhite, nother);
}
```

當把這段程式碼本身作為輸入時，其輸出結果為：

```
digits = 8 2 0 0 0 0 0 0 0 1, white space = 185, other = 297
```

### 1.5.1 陣列宣告

在第 5 行中，我們用 `int ndigit[10] = {0};` 宣告一個長度為 10 的整數陣列，並將其每個元素資料初始化為 `0`。

在 C 語言中，陣列的索引總是由 0 開始，因此該陣列的 10 個元素分別為 `ndigit[0]`、`ndigit[1]`、…、`ndigit[9]`，陣列的索引可以是任何整數變數或常數。

這個程式的執行取決於數字的字元表式形式。例如使用以下的方式判斷 `c` 的字元是否為數字字元：

```c
if (c >= '0' && c <= '9')
```

如果它是數字字元，則對應的數字數值為：

```c
c - '0'
```

這種做法只有當 `'0'`、`'1'`、…、`'9'` 這樣具有連續遞增的值時，這種做法才可行。幸運的是，所有的字元集合都是這樣被定義的。

我們知道 `c` 是一個整數型態 `int`，而且在判斷過 `if (c >= '0' && c <= '9')` 之後可以確保 `c-'0'` 的值介於 0 到 9 之間，可以合法作為陣列的索引。

### 1.5.2 多重判定

判斷一個字元是數字、空白或其它字元由下列陳述式完成：

```c
if (c >= '0' && c <= '9')
    ++ndigit[c-'0'];
else if (c == ' ' || c == '\n' || c == '\t')
    ++nwhite;
else
    ++nother;
```

在程式中常常會使用以下方式來完成多重判定：

```
if (判斷式 1)
    陳述式 1
else if (判斷式 2)
    陳述式 2
...
...
else
    陳述式 n
```

利用這種方式，依次從上到下判定，直到滿足某個條件再執行對應的陳述式。在執行完陳述式之後，整個 `if-elseif-else` 區塊都會結束。如果所有條件都不滿足，則執行位於最後一個 `else` 之後的陳述式，如果不存在 `else` 則該區塊並不會執行任何動作。

就程式設計的風格來說，我們建議讀者採用上述的排版方式來呈現結構的層次關係，以獲得清晰的可讀性。

## 1.6 函式

函式為計算的封裝提供了一種簡潔的方式，使用設計正確的函式，程式設計師不需要考慮功能是如何被實現的，僅需要知道它具有哪些功能即可。在 C 語言中可以簡單、方便、高效地使用函式，也會經常見到宣告後僅調用了一次的短函式，因為這麼做可以讓程式碼更加清晰易讀。

截至目前為止，我們所使用的函式（如 `puts`、`printf`、`getchar` 和 `putchar` 等）都是由標準函式庫提供的函式。現在，是時候讓我們自己動手來撰寫一些函式：不像 Python 這類語言有提供 `**` 這樣的求取 _冪次（Power）_ 的運算元，因此我們需要自己編寫一個求冪函式 `power(m, n)` 來說明函式定義的方法。

`power(m, n)` 函式用於計算整數 `m` 的 `n` 次方，其中 `m` 與 `n` 皆為正整數。對函式調用 `power(2, 5)` 來說，其結果應該為 32。這個函式並不是一個實用的求冪函式，因為它能夠處理的數值範圍有限，但對於解說而言已經足夠了。（附帶一提，其實標準庫 `math.h` 中有提供計算 $x^y$ 的函式 `pow(x, y)`）

以下是函式 `power(m, n)` 的定義與如何調用它的完整程式：

```c
#include <stdio.h>

int power(int m, int n);

int main() {    
    for (int i = 0; i < 10; ++i)
        printf("%d %d %d\n", i, power(2, i), power(-3, i));
}

int power(int base, int n) {
    int p = 1;

    for (int i = 1; i <= n; ++i)
        p *= base;
    return p
}
```

在第 3 行，我們率先定義了 _函式原型（Funcion Prototype）_，用於提示接下來在 `main` 函式使用時的函回傳值及參數列表：

```c
int power(int m, int n);
```

而從第 10 行開始，我們才給出 _函式定義（Function Definition）_，用於實際給出函式的具體執行流程：

```c
int power(int base, int n) {
    int p = 1;

    for (int i = 1; i <= n; ++i)
        p *= base;
    return p;
}
```

### 1.6.1 函式原型

函式原型應該被寫在實際使用的位置之前，但這是可以直接被函式定義替代的。以下的範例就是用函式定義取代函式原型的使用：

```c
#include <stdio.h>

int power(int base, int n) {
    int p = 1;

    for (int i = 1; i <= n; ++i)
        p *= base;
    return p;
}

int main() {    
    for (int i = 0; i < 10; ++i)
        printf("%d %d %d\n", i, power(2, i), power(-3, i));
}
```

值得注意的是，函式原型的參數名稱是可選項（但資料型態是必需的），名稱也不要求一定要與函式定義相同（但資料型態必需相符），以下的程式就示範谷在函式原型中使用的是 `m` 及 `n`，但在函式定義中 `m` 被 `base` 所取代：

```c
// function prototype
int power(int m, int n);

// function definition
int power(int base, int n) {
    ...
}
```

良好的命名至關重要，通常會推薦函式原型與函式實作都使用相同的名稱，並且讓其它的程式設計師可以一眼看出該函式的作用與如何運作是最好的。

### 1.6.2 函式定義

函式定義的常見形式為：

```
回傳型態 函式名(0 個或複數個參數宣告)
{
    1 個以上的陳述式
}
```

我們可以在 `power` 函式定義中套用這個形式：

```c
int power(int base, int n) {
    int p = 1;

    for (int i = 1; i <= n; ++i)
        p *= base;
    return p;
}
```

- 回傳型態：`int`
- 函式名：`power`
- 參數：
    - `int base`
    - `int n`
- 陳述式：
    - `int p = 1;`
    - `for (int i = 1; i <= n; ++i) p *= base;`
    - `return p;`

函式參數或是在函式中被宣告的變數，對於其它函式都是不可見的，在其它函式中我們可以大膽地使用相同名稱的變數（例如在 `main` 與 `power` 都存在變數 `i`，但它們是獨立、互不影響的）

### 1.6.3 回傳陳述式

對於 `power` 的計算結果，會透過 `return` 陳述式將其回傳給 `main` 函式。

```c
return p;
```

對於存在回傳型態的函式來說，都應該使用 `return` 陳述式將指定的值回傳給調用函式的地方，然而並不是所有函式都存在回傳型態，可以使用 `return ;` 表達函式已經到了盡頭但不回傳任何有用的值。

你可能注意到了，`main` 函式有被定義回傳值 `int`，但是上述的所有程式都沒有在 `main` 函式的末尾加上 `return` 陳述式。這是因為 `main` 函式較為特殊，規範並不要求它一定要顯式使用回傳值，這種情況會自動地 `return 0`。一般來說，`main` 函式的回傳值為 0 時表示程式正常中止，反之則表示出現異常情況或出錯。

### 1.6.4 函式參數

在 C 語言中，函式參數是 _傳值調用（Call By Value）_ 的，用比較口語的方式解釋就是：在函式內對參數的變更並不會影響到調用者。

我們來看一個例子：

```c
#include <stdio.h>

void increment(int num) {
    ++num;
    printf("incremented: %d\n", num);
}

int main() {
    int n = 100;

    increment(n);

    printf("n = %d\n", n);
}
```

我們定義了一個函式 `increment`、傳入參數 `num`，並且使用 `++num` 將其遞增。然而在 `main` 函式執行過這個函式之後卻意外地發現 `n` 的值並不會有任何變化。

這種傳值調用利大於弊，在函式中可以將參數視為方便初始化的局部變數，因此降低額外的使用負擔，同時也可以讓程式碼更加緊湊簡潔。

讀者可能有注意到，`increment` 是一個不產生回傳的函式，這種情況會使用 `void` 作為其回傳值資料型態。

## 1.7 字元陣列

字元陣列是 C 語言中最常用的陣列類別，下面我們會撰寫一個程式來說明字元陣列及操作它的函式的用法。這個程式會讀入多行文字，並且把最長的文字輸出，這個演算法相當簡單：

```
while (還有未處理的行)
    if (當前的行比已經處理過的最長行還要長)
        保存當前行為最長行
        保存當前行的長度
輸出最長的行
```

由上面的說明可以看出，這個程式很自然地分成了若干片段：讀入新行、測試讀入的行、保存該行，其餘部份則是控制這個邏輯。

因為這種劃分方式比較合理，所以可以按照這種方式撰寫程式碼。首先，我們需要設計一個獨立的函式 `getLine`，它會讀取輸入的下一行。我們可以讓 `getLine` 在讀取該行時回傳該行的長度，並且當遇到文件結尾 `EOF` 時回傳 0，由於 0 並不是一個有效的行長度（因為「一行」至少會存在一個換行字元 `\n`）這樣就可以很輕易地判定是否讀取完畢。

當發現某個新讀入的行要比之前的最長行還要長時，就要把該行保存下來。我們需要另一個函式 `copy` 把新行複製到一個安全的位置。

最後，我們在 `main` 函式中調用 `getLine` 與 `copy` 這兩個函式，即可完成程式碼：

```c
#include <stdio.h>

#define MAXLEN 1000 // maximum input line length

int getline(char s[], int limit);
void copy(char to[], char from[]);

int main() {
    int len;              // current line length
    int max = 0;          // maximum length seen so far
    char line[MAXLEN];    // current input line
    char longest[MAXLEN]; // longest line saved here

    while ((len = getline(line, MAXLEN)) > 0) {
        if (len > max) {
            max = len;
            copy(longest, line);
        }
    }
    if (max > 0) // there was a line
        puts(longest);
}

int getLine(char s[], int limit) {
    int c;

    for (int i = 0; i < limit-1 && (c = getchar()) != EOF && c != '\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void copy(char to[], char from[]) {
    for (int i = 0; (to[i] = from[i]) != '\0'; ++i)
        ;
}
```

在程式的開頭對 `getLine` 與 `copy` 兩個函式建立了原型，這裡假設它們都被存放在同一個檔案中。

`main` 與 `getLine` 通過一對參數及一個回傳值進行資料交換，在 `getLine` 函式中，兩個參數透過 `int getLine(char s[], int limit)` 宣告，第一個參數 `s` 為字元陣列，第二個 `limit` 為整數。

`getLine` 函式中，會將 `'\0'` 字元插入到 `s` 的末尾，在 C 語言中這是一個字串結束的標記，`'\0'` 是一個逃脫字元，稱為 _空字元（Null Character）_ 其代表值為 0

舉例來說，在 C 語言中如果使用 `"Hello World"` 這樣的字串，其實等價於於以下字元陣列：

```
+---+---+---+---+---+--+---+---+---+---+---+----+
| H | e | l | l | o |  | W | o | r | l | d | \0 |
+---+---+---+---+---+--+---+---+---+---+---+----+
```

標準函式庫中的 `puts` 與 `printf("%s")` 函式中要求字元陣列必需符合字串的規範，且 `copy` 函式的實現也是依賴於輸入參數由 `'\0'` 結束的這一規則並將 `'\0'` 複製到輸出中（換句話說，空字元並不是輸入文本的一部份）

值得一提的是，即使是上述這樣較小的程式，在傳遞參數時也會遇到一些麻煩的設計問題。例如，當讀入的行長度大於允許的最大值時，`main` 函式應該如何處理，`getLine` 函式的執行是安全的，無論是否達到換行字元，當陣列已滿時就該停止讀取字元。`main` 函式則可以透過測試行的長度以及檢查回傳備直的最後一個字元來判定當前行是否太長，然後再根據具體情況處理。此處為了簡化問題，這個部份我們暫且擱置。

呼叫 `getLine` 函式並無法預先知道輸入行的長度，因此 `getLine` 函式需要檢查是否 _溢出（Overflow）_。另一方面，調用 `copy` 函式的程式知道字串長度，因此該函式不需要進行錯誤檢查。