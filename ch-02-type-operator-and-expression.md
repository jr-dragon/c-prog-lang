# 第 2 章：資料型態、運算元與表達式

變數與常數是程式中兩種基本的資料對象。宣告陳述式說明變數的資料型態與名稱，也可以同時指定該變數的初始值；運算元則是用於指定要對資料進行的操作；_表達式（Expression）_ 則是用於把變數與常數組合起來的操作。

資料類型決定該資料可取值的集合以及可以對該對象執行的操作，本章將會詳細講述這些內容。

## 2.1 變數名稱

對變數與符號常數的命名存在一些限制條件，我們在[第 1 章](./ch-01-introduction.md)刻意忽略了這個部份的說明。

變數名是由字母及數字組成的序列，但首字元必須是字母。底線 `_` 會被視為字母的一種，通常用於命名較長的變數以提高其可讀性。大寫與小寫會被視為不同的字母，所以 `int x` 與 `int X` 會被視為兩個不同的變數，在傳統上變數名盡量使用小寫、符號常量則全部使用大寫以區分。

:::warn
雖然 C 語言允許宣告及使用以 `_` 開頭的變數，但是在 C 語言的演進過中程往往會將 `_` 開頭的變數保留給後續功能使用，所以實際在開發時應當避免。
:::

類似於 `if`、`else`、`int`、`float` 等 C 語言的關鍵字是保留給語言本身使用的，不能將其作為變數名稱，且所有的關鍵字都必須是小寫。

變數名稱應該要盡量能夠從字面上表達其用途，以免產生混淆。區域變數一般會習慣使用較短的變數名稱或是約定俗成的縮寫，而全域變數則會選用較長的名稱。

## 2.2 資料型態與大小

在 C 語言中的基本資料型態如下：

- `char`：字元型別，僅佔用 1 byte
- `int`：整數型別，反應了當前硬體或作業系統中整數的最自然長度
- `float`：單精度浮點型別
- `double`：倍精度浮點型別

### 2.2.1 整數型別

對於整數型別，可以在前面加上 `short` 或 `long` 修飾符：

```c
short int sh;
long int counter;
long long int timestamp;
```

在上述的宣告中關鍵字 `int` 可以省略寫成 `short sh`、`long counter` 或 `long long timestamp`。

讀者應該有注意到，我們並沒有直接說明 `int`、`short int`、`long int` 及 `long long int` 的資料大小，這是因為在 C 語言設計的時候考慮到不同硬體會有不同的需求所以對此並沒有明確規範。

:::info
對於現代 C 語言開發，建議讀者在使用整數型別應該優先使用標準函式庫 `stdint.h` 中的型別定義以避免歧義，在 `stdint.h` 中會定義一系列有固定大小的資料型態，它的格式應該是 `intN_t`，其中 `N` 可以代換為固定大小的值，例如 `int8_t` 代表是佔用 8 bits 的整數。
:::

順帶一提，字元型別 `char` 可以被視為一種整數型別。

### 2.2.2 浮點數型別

浮點數可以想像成「帶有小數點的數值」，在 C 語言中共有三個可以代表浮點數的型別：
- `float`
- `double`
- `long double`

與 `int` 類型一樣，它們並沒有規定明確的資料大小，只規定了 `float` 必定小於等於 `double`、`double` 必定小於等於 `long double`。

在絕大部份情況下，`float` 通常指的是 32 bits 浮點數、`double` 則是 64 bits 浮點數，而 `long double` 相對罕見得多。

:::warn
浮點數是藉由犧牲了精確度來換取表達更大的值的手段，因此對於需要精確數值操作的領域（如金融或商務領域）不冒貿然使用浮點數表示。
:::

### 2.2.3 類型限制符

類型限定符 `signed` 與 `unsigned` 可以用於整數型別，分別代表「有負號」與「無負號」，它們可以被放在整數型別之前。

舉例來說，`signed char` 取值範圍會落在 -128 到 127 之間（在絕大多數硬體上的行為），而 `unsigned char` 的取值範圍則是落在 0 到 255 之間。

對於 `int`、`short int`、`long int` 與 `long long int`，它們會是有負號整數，所以通常會把 `signed` 省略下來；若是特別需要無負號整數，就需要加上 `unsigned` 限制符。

`float` 與 `double` 在定義上已經保證它們可同時支援有負號與無負號，因此無法在上面使用類型限制符。

### 2.2.4 limits.h 與 float.h

如果要精確得知當前平台上的各資料型態上下限值，可以使用 `limits.h` 與 `float.h` 標頭檔中的定義。

```c
#include <stdio.h>
#include <limits.h>
#include <float.h>

int main() {
    printf("maximum value of int: %d\n", INT_MAX);
    printf("minimum value of int: %d\n", INT_MIN);

    printf("maximum value of float: %f\n", FLT_MAX);
    printf("minimum value of float: %f\n", FLT_MIN);
}
```

這些值在不同的硬體、作業系統或編譯器中可能會有差異，在實際開發之前最好都先確認這些值以避免歧異。

## 2.3 常數

### 2.3.1 整數常數

在程式碼中，類似於 `int n = 1234` 中的 `1234` 是一個整數類型的常數，也可以在整數常數加上後綴 `l` 或 `ll` 代表 `long int` 與 `long long int`。需要宣告無負號常數，則使用 `u` 作為後綴，並且可以與 `l` 或 `ll` 後綴一起使用。

```c
int main() {
    int n = 1234;
    long long int lln = 1234ll;
    unsigned long long int ulln = 1234ull;
}
```

除了使用十進位來表達整數常數之外，C 語言還支援使用二進位、八進位或十六進位表示整數常數。
- 帶有前綴 `0b` 或 `0B` 代表二進位
- 帶有前綴 `0` 代表八進位
- 帶有前綴 `0x` 或 `0X` 代表十六進位

:::info
以 `0b` 或 `0B` 代表二進位的整數常數直到 C23 才被寫入規範，儘管 GCC 與 Clang 先前已經以編譯器擴展的方式支援這種寫法，但在過去的規範或比較舊版的編譯器是不支援這樣的寫法的。
:::

整數常數也可以使用 `l` 或 `ll` 後綴來代表長整數型態，或是使用 `u` 後綴來代表無負號整數。

### 2.3.2 浮點常數

浮點常數則是包含一個小數點（如 `123.4`）或一個科學計數法表達式（如 `1e-2`），也可以兩者兼具（如 `1.23e6`）。沒有後綴的浮點常數是 `double` 類別，如果使用 `f` 作為後綴則是 `float` 類別。

```c
int main() {
    double d1 = 123.4;
    double d2 = 1e-2;
    double d3 = 1.23e6;
    float f = 123.4f;
}
```

### 2.3.3 字元常數

就如同 `char` 是一種整數型態，字元其實可以視為一個整數，只不過在撰寫程式碼時會將其包裏在單引號 `''` 中，例如 `'x'`。

字元一般使用 ASCII 字元集，在這個字元集中 `'0'` 的值是 48，它與數值 0 沒有關係，但是使用字元 `'0'` 來代替程式碼中與字元集有關的值可以增加程式的可讀性。字元常數一般用來與其它字元進行比較（例如 `c >= '0' && c <= '9'`，我們可以推論變數 `c` 是一個數字字元），不過也可以像其它整數一樣參與運算。

某些字元可以透過逃脫字元轉義，例如換行字元 `\n` 來表示字元，雖然在程式碼中它們看起來是兩個字元，但其實只表達一個字元。另一方面，使用 `'\ooo'` 或 `'\xhh'` 可用於表達任意的位元組大小，其中 `ooo` 代表 1 到 3 個八進位數字（0 到 7），而 `hh` 則表示一個或多個十六進位數字：

```c
#define VTAB '\013' // ASCII vertical tab
#define BELL '\007' // ASCII bell character

#define VTAB_HEX '\xb' // ASCII vertical tab
#define BELL_HEX '\x7' // ASCII bell character
```

常數表達式是僅包含常數的表達式，這種表達式會在編譯階段求值，它可以出現任何常數可以出現的位置，例如：

```c
#define MAXLINE 1000
char line[MAXLINE+1];

#define LEAP 1 // in leap year
int days[+28+LEAP+31+30+31+30+31+31+30+31+30+31];
```

### 2.3.4 字串常數

字串指的是使用雙引號 `""` 包裏起來的複數個字元組成的字元序列，例如 `"I am a string"` 或 `""`，對於沒有任何字元組成的字串稱其為「空字串」。雙引號 `""` 並不是字串的一部份，它僅僅是用於限定字串的定義。

字串常數中也可以使用逃脫字元，例如 `"This is my dog.\nIt is very cute."`。

多個相鄰的字串會在編譯階段被拼接，例如 `"Hello," " World"` 等價於 `"Hello, World"`，這讓較長的字串能夠被換行或分散在各檔案中提供了可能性，下面的程式以《創世紀》第一章的第一節與第二節為範例：

```c
#include <stdio.h>

int main() {
    puts(
        "In the beginning God created the heavens and the earth. "
        "Now the earth was formless and empty, darkness was over the surface of the deep, and the Spirit of God was hovering over the waters."
    );
}
```

從技術的角度來看，字串常數事實上就是字元陣列。正如同在[第 1 章：字串](./ch-01-introduction.md)中提到的，字串內部會使用一個 `'\0'` 標記為結尾，因此儲存字串的物理存儲單元會比雙引號中的字元數多一個，因為這種表達方式，C 語言對字串的長度沒有限制，但程式也必須走訪過整個字串才能確定字串長度。

在標準函式庫中，使用 `strlen` 可以取得字串的長度，該長度不包括結尾的 `'\0'`，以下是一個基礎的 `strlen` 函式實現：

```c
int strlen(char s[]) {
    int i;
    for (i = 0; s[i] != '\0'; ++i)
        ;
    return i;
}
```

我們需要特別注意字元使用的 `''` 與字串所使用的 `""` 有區別，`'x'` 與 `"x"` 是不同的，前者是一個 `char`，其值為 ASCII 所對應的數值；後者則是包含一個字元（字母 `x`）以似一個結尾字元的 `'\0'` 字元陣列。

### 2.3.5 枚舉

枚舉常數是另外一種類別的常數，它是一個常數的集合，例如：

```c
enum boolean { NO, YES };
```

在沒有顯示指定的情況下，`enum` 類別中的第一個值為 0、第二個值為 1，以此類推。如果只指定了部份枚舉值的枚舉名，將會從最後一個已指定值向後遞增，下述的例子中 `FEB` 值為 2、`MAR` 值為 `3`…，以此類推：

```c
enum months {
    JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC
};
```

枚舉提供了一個便利的方式來關聯值與名稱，相較於 `#define` 來說，它的優勢在於常數值可以被自動生成。雖然可以宣告 `enum` 類型的變數，但編譯器並不會檢查這種類型的變數中儲存的值是否為該枚舉的有效值，編譯器僅會檢查枚舉的資料型態是否合法。

## 2.4 宣告

所有的變數都必須先 _宣告（Declaration）_ 後才能使用，儘管某些變數可以透過上下文隱式宣告。

所謂宣告，指的是規定一種變數型態，並且後面的變數列表可以包含一個或多個該類型的變數。例如：

```c
int lower, upper, step;
char c, line[1000];
```

一個宣告陳述式中的多個變數可以被拆在多個宣告陳述式中，上面的例子也可以被等價地對應到下列形式：

```c
int lower;
int upper;
int step;
char c;
char line[1000];
```

然而，用這種方式書寫會佔用較多的空間，而且無法很明晰地確定變數之間的關係，雖然也有加上註釋與保留未來修改的便利性，程式設計師可以按照自己的需求做出取捨。

在宣告變數的同時也可以進行初始化，只要在宣告的時候加上一個等號與陳述式即可。

```c
char esc = '\\';
int i = 0;
int limit = MAXLINER+1;
float eps = 1.0e-5;
```

任何的變數宣告都可以加上 `const` 關鍵字作為前綴來限制該變數後續不可被修改。對於陣列而言，如果使用 `const` 前綴則該陣列的所有元素值都不能被修改：

```c
const double e = 2.71828182845905;
const char msg[] = "warning: ";
```

`const` 也可以配合函式參數使用，它表明函數不能修改該參數的值，以下用我們在 1.6 節中所實現的 `power` 函式作為範例：

```c
int power(const int base, const int n) {
    int p = 1;

    for (int i = 1; i <= n; ++i)
        p *= base;
    return p;
}
```

基本上，如果在設計函式時已經確定該參數不會被變更，都應該盡量設為 `const` 為宜。

值得一提的是，如果函式的陣列參數以 `const` 修飾，則該陣列中的值都不能被函式修改，如果違反了這項規則會導致 _未定義行為（Undefined Behavior）_，例如標準函式庫中的 `strlen` 函式原型如下：

```c
int strlen(const char[]);
```

:::warn
使用未定義行為在撰寫程式碼時應該被極力避免，因為它會在不同的作業系統、編譯器或執行環境中產生不同的結果，這會使得程式碼變得不可控。

本書並不會特別探討哪些行為是未定義行為，僅會在其發生時稍微提及。
:::

## 2.5 算術運算元

在 C 語言中共有 `+`、`-`、`*`、`/` 與 `%` 幾種二元運算元，其優先順序類似於我們在算術中常用的「先乘除後加減」的規則，並且採用從左往右運算（可以使用 `()` 提高加減的運算優先級）。

需要特別注意的是，如果在兩個整數中使用 `/` 運算元會截斷小數部份，例如 `14/5` 的結果會是 2。

另外 `%` 稱為「取餘運算元」，例如 `x % y` 的結果會是 `x` 除以 `y` 的餘數；如果 `x` 能被 `y` 整數，則該值為 0，可以用以下程式很方便地計算出某一年是不是閏年：

```c
if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
    printf("%d is a leap year\n", year);
else
    printf("%d is not a leap year\n", year);
```

取餘運算元不能被用於 `float` 與 `double` 類型。

## 2.6 關係運算元、相等性運算元與邏輯運算元

用比較口語的方式來說，_關係運算元（Relational Operator）_ 就是「比大小」，其中包含
- `>`：大於
- `>=`：大於等於
- `<`：小於
- `<=`：小於等於

關係運算元的優先級比算術運算元來得低，因此，`i < limit-1` 等價於 `i < (limit-1)`。

_相等性運算元（Equality Operator）_ 使用 `==` 判定「相等」或 `!=`「不相等」，它們的優先級比關係運算元來得低一些。

關係運算元與相等性運算元的結果會是 `true` 或 `false`，表示條件成立或不成立。例如，`5 > 3` 是成立的；`8 <= 1` 則是不成立的。

_邏輯運算元（Logical Operator）_ `&&` 與 `||` 則是用於為 `true` 與 `false` 進行判斷的運算元（在 C 語言中，任何非 0 的值都是 `true`，反之則是 `false`）。邏輯運算元有個特殊的屬性，它們會由左往右順序進行，並且如果已經知道結果之後會立即停止計算。絕大多數 C 語言的程式碼都會使用這個特性，例如在第一章我們實現的 `get_line` 函式中：

```c
for (i = 0; i < limit-1 && (c = getchar()) != EOF && c != '\n'; ++i)
    s[i] = c;
```

我們率先檢查 `i < limit-1`，用於檢查陣列是否還有空間存放，如果這個條件測試失敗，就沒有必要繼續讀取下一個字元。

同理可證，如果在調用 `getchar()` 函式之前就測試 `c` 是否為 `EOF`，其結果也不會是正確的。因此，函式的調用與賦值都必須在對 `c != EOF` 之前被執行。 

在關係表達式、相等性表達式或邏輯表達式中，如果關係為真，則表達式結果為數值 1；反之則為數值 0。

最後，邏輯非運算元 `!` 的作用是將非 0 轉為 0、將 0 轉為 1，該運算元通常用於類似於 `if (!valid)`，雖然等價於 `if (valid == 0)`，但是 `!valid` 的用法讀起來會更直觀一些，不過對於複雜的語句可能會變得難以理解。